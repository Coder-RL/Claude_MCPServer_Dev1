import { StandardMCPServer, MCPTool } from '../../shared/standard-mcp-server';
import { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import * as fs from 'fs/promises';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

// Simple cache implementation for Security
class SecurityCache<T> {
  private cache = new Map<string, { value: T; timestamp: number; hits: number }>();
  private maxSize: number;
  private maxAge: number;

  constructor(maxSize = 50, maxAge = 300000) { // Reduced default sizes
    this.maxSize = maxSize;
    this.maxAge = maxAge;
  }

  set(key: string, value: T): void {
    this.evictExpired();
    if (this.cache.size >= this.maxSize) {
      this.evictLRU();
    }
    this.cache.set(key, { value, timestamp: Date.now(), hits: 0 });
  }

  get(key: string): T | undefined {
    const entry = this.cache.get(key);
    if (!entry) return undefined;
    if (Date.now() - entry.timestamp > this.maxAge) {
      this.cache.delete(key);
      return undefined;
    }
    entry.hits++;
    return entry.value;
  }

  private evictExpired(): void {
    const now = Date.now();
    for (const [key, entry] of this.cache) {
      if (now - entry.timestamp > this.maxAge) {
        this.cache.delete(key);
      }
    }
  }

  private evictLRU(): void {
    let lruKey = '';
    let lruHits = Infinity;
    for (const [key, entry] of this.cache) {
      if (entry.hits < lruHits) {
        lruHits = entry.hits;
        lruKey = key;
      }
    }
    if (lruKey) this.cache.delete(lruKey);
  }

  clear(): void {
    this.cache.clear();
  }

  size(): number {
    return this.cache.size;
  }
}

// Simplified interfaces for Security
export interface Vulnerability {
  id: string;
  title: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  type: string;
  description: string;
  affected: string;
  remediation: string;
  references: string[];
  status: 'open' | 'resolved' | 'ignored' | 'false_positive';
  discoveredAt: Date;
  updatedAt: Date;
}

export interface ScanResult {
  id: string;
  projectPath: string;
  scanTypes: string[];
  platforms: string[];
  vulnerabilities: Vulnerability[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  timestamp: Date;
  duration: number;
}

export interface SecurityScanConfig {
  scanTypes: string[];
  platforms: string[];
  excludePatterns: string[];
  customRules: any[];
  integrations: any[];
  reporting: {
    format: string;
    includeRemediation: boolean;
    includeCVEDetails?: boolean;
    groupBy?: string;
    metrics?: boolean;
  };
}

// Simplified Security Service
class SecurityVulnerabilityService {
  private scanResultCache = new SecurityCache<ScanResult>(10, 1800000);
  private vulnerabilityCache = new SecurityCache<Vulnerability>(20, 900000);
  private config: SecurityScanConfig;

  constructor(config: SecurityScanConfig) {
    this.config = config;
  }

  async scanProject(projectPath: string, options?: any): Promise<ScanResult> {
    const cacheKey = `${projectPath}_${JSON.stringify(options)}`;
    const cached = this.scanResultCache.get(cacheKey);
    if (cached) {
      return cached;
    }

    const startTime = Date.now();
    
    // Simplified scan implementation
    const vulnerabilities: Vulnerability[] = await this.performScan(projectPath, options);
    
    const result: ScanResult = {
      id: `scan_${Date.now()}`,
      projectPath,
      scanTypes: options?.scanTypes || this.config.scanTypes,
      platforms: options?.platforms || this.config.platforms,
      vulnerabilities,
      summary: this.calculateSummary(vulnerabilities),
      timestamp: new Date(),
      duration: Date.now() - startTime
    };

    this.scanResultCache.set(cacheKey, result);
    return result;
  }

  async getVulnerabilityById(vulnerabilityId: string): Promise<Vulnerability | null> {
    const cached = this.vulnerabilityCache.get(vulnerabilityId);
    if (cached) {
      return cached;
    }

    // Simplified vulnerability lookup
    const vulnerability: Vulnerability = {
      id: vulnerabilityId,
      title: `Vulnerability ${vulnerabilityId}`,
      severity: 'medium',
      type: 'dependency',
      description: 'Sample vulnerability description',
      affected: 'package@1.0.0',
      remediation: 'Update to latest version',
      references: [],
      status: 'open',
      discoveredAt: new Date(),
      updatedAt: new Date()
    };

    this.vulnerabilityCache.set(vulnerabilityId, vulnerability);
    return vulnerability;
  }

  async updateVulnerabilityStatus(vulnerabilityId: string, status: string): Promise<any> {
    const vulnerability = await this.getVulnerabilityById(vulnerabilityId);
    if (vulnerability) {
      vulnerability.status = status as any;
      vulnerability.updatedAt = new Date();
      this.vulnerabilityCache.set(vulnerabilityId, vulnerability);
    }
    return { success: true, vulnerabilityId, status };
  }

  async generateReport(scanId: string, format?: string): Promise<any> {
    return {
      scanId,
      format: format || 'json',
      generated: new Date(),
      content: {
        summary: 'Security scan report',
        recommendations: []
      }
    };
  }

  async listScans(): Promise<any> {
    return {
      scans: [],
      total: 0,
      timestamp: new Date()
    };
  }

  private async performScan(projectPath: string, options?: any): Promise<Vulnerability[]> {
    // Simplified scan logic - in real implementation would run actual security tools
    const scanTypes = options?.scanTypes || ['dependencies'];
    const vulnerabilities: Vulnerability[] = [];

    if (scanTypes.includes('dependencies')) {
      // Mock dependency scan
      vulnerabilities.push({
        id: `vuln_${Date.now()}`,
        title: 'Outdated dependency detected',
        severity: 'medium',
        type: 'dependency',
        description: 'Package has known vulnerabilities',
        affected: 'example-package@1.0.0',
        remediation: 'Update to version 2.0.0+',
        references: [],
        status: 'open',
        discoveredAt: new Date(),
        updatedAt: new Date()
      });
    }

    return vulnerabilities;
  }

  private calculateSummary(vulnerabilities: Vulnerability[]): any {
    const summary = { total: 0, critical: 0, high: 0, medium: 0, low: 0 };
    
    vulnerabilities.forEach(vuln => {
      summary.total++;
      summary[vuln.severity]++;
    });

    return summary;
  }

  getHealthStatus(): any {
    return {
      status: 'healthy',
      cacheSize: this.scanResultCache.size(),
      timestamp: new Date()
    };
  }

  clearCaches(): void {
    this.scanResultCache.clear();
    this.vulnerabilityCache.clear();
  }
}

export class SecurityVulnerabilityServer extends StandardMCPServer {
  private securityService?: SecurityVulnerabilityService; // Lazy loading
  private memoryMonitorInterval?: NodeJS.Timeout;

  constructor() {
    super('security-vulnerability-server', 'Security Vulnerability Scanning and Assessment Server');
    // Keep constructor minimal - no service creation
  }

  async setupTools(): Promise<void> {
    // Register tools only - no service initialization
    this.registerTool({
      name: 'scan_project_security',
      description: 'Perform comprehensive security vulnerability scan of a project',
      inputSchema: {
        type: 'object',
        properties: {
          projectPath: { type: 'string', description: 'Path to the project to scan' },
          scanTypes: {
            type: 'array',
            items: { enum: ['dependencies', 'static_analysis', 'secrets', 'configuration'] },
            description: 'Types of security scans to perform'
          },
          platforms: {
            type: 'array',
            items: { enum: ['web', 'nodejs', 'python'] },
            description: 'Target platforms to scan for'
          }
        },
        required: ['projectPath']
      }
    });

    this.registerTool({
      name: 'get_vulnerability_details',
      description: 'Get detailed information about a specific vulnerability',
      inputSchema: {
        type: 'object',
        properties: {
          vulnerabilityId: { type: 'string', description: 'Unique identifier of the vulnerability' }
        },
        required: ['vulnerabilityId']
      }
    });

    this.registerTool({
      name: 'update_vulnerability_status',
      description: 'Update the status of a vulnerability (resolved, ignored, etc.)',
      inputSchema: {
        type: 'object',
        properties: {
          vulnerabilityId: { type: 'string', description: 'Vulnerability ID to update' },
          status: { type: 'string', enum: ['open', 'resolved', 'ignored', 'false_positive'], description: 'New status' }
        },
        required: ['vulnerabilityId', 'status']
      }
    });

    this.registerTool({
      name: 'generate_security_report',
      description: 'Generate security assessment report',
      inputSchema: {
        type: 'object',
        properties: {
          scanId: { type: 'string', description: 'Scan ID to generate report for' },
          format: { type: 'string', enum: ['json', 'html', 'csv'], default: 'json', description: 'Report format' }
        },
        required: ['scanId']
      }
    });

    this.registerTool({
      name: 'list_recent_scans',
      description: 'List recent security scans',
      inputSchema: {
        type: 'object',
        properties: {
          limit: { type: 'number', default: 10, description: 'Maximum number of scans to return' }
        }
      }
    });

    this.registerTool({
      name: 'check_dependency_vulnerabilities',
      description: 'Scan project dependencies for known vulnerabilities',
      inputSchema: {
        type: 'object',
        properties: {
          projectPath: { type: 'string', description: 'Path to the project to scan' }
        },
        required: ['projectPath']
      }
    });

    // Do NOT start memory monitoring here!
  }

  private getSecurityService(): SecurityVulnerabilityService {
    if (!this.securityService) {
      const defaultConfig: SecurityScanConfig = {
        scanTypes: ['dependencies', 'static_analysis', 'secrets'],
        platforms: ['web', 'nodejs', 'python'],
        excludePatterns: ['node_modules', '.git', 'dist', 'build'],
        customRules: [],
        integrations: [
          { name: 'npm_audit', type: 'npm_audit', config: {}, enabled: true }
        ],
        reporting: {
          format: 'json',
          includeRemediation: true,
          includeCVEDetails: true,
          groupBy: 'severity',
          metrics: true
        }
      };
      this.securityService = new SecurityVulnerabilityService(defaultConfig);
    }
    return this.securityService;
  }

  async handleToolCall(toolName: string, parameters: any): Promise<CallToolResult> {
    const service = this.getSecurityService(); // Lazy loading

    switch (toolName) {
      case 'scan_project_security':
        const scanResult = await service.scanProject(parameters.projectPath, {
          scanTypes: parameters.scanTypes,
          platforms: parameters.platforms
        });
        return { content: [{ type: 'text', text: JSON.stringify(scanResult, null, 2) }] };

      case 'get_vulnerability_details':
        const vulnDetails = await service.getVulnerabilityById(parameters.vulnerabilityId);
        return { content: [{ type: 'text', text: JSON.stringify(vulnDetails, null, 2) }] };

      case 'update_vulnerability_status':
        const updateResult = await service.updateVulnerabilityStatus(parameters.vulnerabilityId, parameters.status);
        return { content: [{ type: 'text', text: JSON.stringify(updateResult, null, 2) }] };

      case 'generate_security_report':
        const report = await service.generateReport(parameters.scanId, parameters.format);
        return { content: [{ type: 'text', text: JSON.stringify(report, null, 2) }] };

      case 'list_recent_scans':
        const scans = await service.listScans();
        return { content: [{ type: 'text', text: JSON.stringify(scans, null, 2) }] };

      case 'check_dependency_vulnerabilities':
        const depScanResult = await service.scanProject(parameters.projectPath, {
          scanTypes: ['dependencies'],
          platforms: ['web', 'nodejs', 'python']
        });
        return { content: [{ type: 'text', text: JSON.stringify(depScanResult, null, 2) }] };

      default:
        throw new Error(`Unknown tool: ${toolName}`);
    }
  }

  // Optional: Start monitoring AFTER server is ready (can be called externally)
  startOptionalMonitoring(): void {
    if (!this.memoryMonitorInterval) {
      this.memoryMonitorInterval = setInterval(() => {
        const memUsage = process.memoryUsage();
        const heapUsedMB = Math.round(memUsage.heapUsed / 1024 / 1024);
        
        if (heapUsedMB > 80) {
          console.log('[Security] Memory critical, clearing caches...');
          this.getSecurityService().clearCaches();
        }
      }, 30000);
    }
  }

  // Cleanup method
  async cleanup(): Promise<void> {
    if (this.memoryMonitorInterval) {
      clearInterval(this.memoryMonitorInterval);
      this.memoryMonitorInterval = undefined;
    }
    
    if (this.securityService) {
      this.securityService.clearCaches();
    }
  }
}

// Start the server if this file is run directly
if (import.meta.url === `file://${process.argv[1]}`) {
  const server = new SecurityVulnerabilityServer();
  server.start().catch(console.error);
}