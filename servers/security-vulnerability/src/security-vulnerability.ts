import { BaseMCPServer } from "../../shared/base-server";
import { MCPError } from '../../../shared/src/errors';
import { HealthChecker } from '../../../shared/src/health';
import * as fs from 'fs/promises';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

// Memory optimization: Set Node.js memory management flags
process.env.NODE_OPTIONS = '--max-old-space-size=512 --gc-interval=100';

// Memory cache with LRU eviction
class MemoryOptimizedCache<T> {
  private cache = new Map<string, { value: T; timestamp: number; hits: number }>();
  private maxSize: number;
  private maxAge: number;

  constructor(maxSize = 100, maxAge = 300000) { // 5 minutes
    this.maxSize = maxSize;
    this.maxAge = maxAge;
  }

  set(key: string, value: T): void {
    this.evictExpired();
    if (this.cache.size >= this.maxSize) {
      this.evictLRU();
    }
    this.cache.set(key, { value, timestamp: Date.now(), hits: 0 });
  }

  get(key: string): T | undefined {
    const entry = this.cache.get(key);
    if (!entry) return undefined;
    if (Date.now() - entry.timestamp > this.maxAge) {
      this.cache.delete(key);
      return undefined;
    }
    entry.hits++;
    return entry.value;
  }

  private evictExpired(): void {
    const now = Date.now();
    for (const [key, entry] of this.cache) {
      if (now - entry.timestamp > this.maxAge) {
        this.cache.delete(key);
      }
    }
  }

  private evictLRU(): void {
    let lruKey = '';
    let lruHits = Infinity;
    for (const [key, entry] of this.cache) {
      if (entry.hits < lruHits) {
        lruHits = entry.hits;
        lruKey = key;
      }
    }
    if (lruKey) this.cache.delete(lruKey);
  }

  clear(): void {
    this.cache.clear();
  }

  size(): number {
    return this.cache.size;
  }
}

// Security Vulnerability Interfaces
export interface VulnerabilityReport {
  id: string;
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
  type: 'dependency' | 'code' | 'configuration' | 'secret' | 'permission';
  title: string;
  description: string;
  affectedFiles: string[];
  cve?: string;
  cvssScore?: number;
  remediation: RemediationSuggestion[];
  confidence: number;
  detectedBy: string[];
  createdAt: Date;
  status: 'open' | 'triaged' | 'fixed' | 'false_positive' | 'accepted_risk';
}

export interface RemediationSuggestion {
  type: 'upgrade' | 'patch' | 'configuration' | 'code_change' | 'removal';
  description: string;
  commands?: string[];
  codeChanges?: CodeChange[];
  priority: 'immediate' | 'high' | 'medium' | 'low';
  effort: 'trivial' | 'easy' | 'moderate' | 'complex';
  testRequired: boolean;
}

export interface CodeChange {
  file: string;
  lineNumber: number;
  originalCode: string;
  suggestedCode: string;
  reason: string;
}

export interface SecurityScanConfig {
  scanTypes: ScanType[];
  platforms: Platform[];
  excludePatterns: string[];
  customRules: SecurityRule[];
  integrations: Integration[];
  reporting: ReportingConfig;
}

export type ScanType = 'dependencies' | 'static_analysis' | 'secrets' | 'permissions' | 'configuration' | 'containers' | 'infrastructure';
export type Platform = 'web' | 'nodejs' | 'python' | 'java' | 'csharp' | 'go' | 'rust' | 'php' | 'ruby' | 'mobile_ios' | 'mobile_android' | 'flutter' | 'react_native';

export interface SecurityRule {
  id: string;
  name: string;
  pattern: string | RegExp;
  severity: VulnerabilityReport['severity'];
  message: string;
  remediation: string;
  platforms: Platform[];
  enabled: boolean;
}

export interface Integration {
  name: string;
  type: 'semgrep' | 'snyk' | 'npm_audit' | 'yarn_audit' | 'pip_audit' | 'bandit' | 'eslint_security' | 'brakeman' | 'gosec' | 'rust_audit' | 'virustotal';
  config: Record<string, any>;
  enabled: boolean;
}

export interface ReportingConfig {
  format: 'json' | 'sarif' | 'html' | 'csv' | 'pdf';
  includeRemediation: boolean;
  includeCVEDetails: boolean;
  groupBy: 'severity' | 'type' | 'file' | 'component';
  metrics: boolean;
}

export interface ScanResult {
  scanId: string;
  projectPath: string;
  startTime: Date;
  endTime: Date;
  duration: number;
  vulnerabilities: VulnerabilityReport[];
  summary: SecuritySummary;
  coverage: CoverageReport;
  recommendations: string[];
}

export interface SecuritySummary {
  total: number;
  bySeverity: Record<VulnerabilityReport['severity'], number>;
  byType: Record<VulnerabilityReport['type'], number>;
  byPlatform: Record<Platform, number>;
  riskScore: number;
  complianceScore: number;
}

export interface CoverageReport {
  filesScanned: number;
  totalFiles: number;
  linesScanned: number;
  totalLines: number;
  platformsCovered: Platform[];
  scanTypesExecuted: ScanType[];
}

// Security Vulnerability Service
export class SecurityVulnerabilityService {
  private config: SecurityScanConfig;
  private activeScans: Map<string, ScanResult> = new Map();
  private scanHistory: ScanResult[] = [];
  
  // Memory optimization caches with size limits
  private vulnerabilityCache = new MemoryOptimizedCache<VulnerabilityReport[]>(30, 600000); // 10 minutes
  private scanResultCache = new MemoryOptimizedCache<ScanResult>(10, 1800000); // 30 minutes
  private dependencyCache = new MemoryOptimizedCache<any>(20, 3600000); // 1 hour

  constructor(config: SecurityScanConfig) {
    this.config = config;
  }

  // Memory optimization methods
  clearCaches(): void {
    this.vulnerabilityCache.clear();
    this.scanResultCache.clear();
    this.dependencyCache.clear();
    
    // Limit scan history to prevent memory bloat
    if (this.scanHistory.length > 20) {
      this.scanHistory = this.scanHistory.slice(-10);
    }
    
    console.log('[Security] Caches cleared for memory optimization');
  }

  async scanProject(projectPath: string, options: Partial<SecurityScanConfig> = {}): Promise<ScanResult> {
    const scanId = this.generateScanId();
    const startTime = new Date();
    
    const scanConfig = { ...this.config, ...options };
    const vulnerabilities: VulnerabilityReport[] = [];

    try {
      // Initialize scan result
      const scanResult: ScanResult = {
        scanId,
        projectPath,
        startTime,
        endTime: new Date(),
        duration: 0,
        vulnerabilities: [],
        summary: this.createEmptySummary(),
        coverage: this.createEmptyCoverage(),
        recommendations: []
      };

      this.activeScans.set(scanId, scanResult);

      // Execute different scan types
      for (const scanType of scanConfig.scanTypes) {
        const typeVulns = await this.executeScanType(scanType, projectPath, scanConfig);
        vulnerabilities.push(...typeVulns);
      }

      // Process and deduplicate vulnerabilities
      const processedVulns = this.processVulnerabilities(vulnerabilities);
      
      // Generate summary and recommendations
      const summary = this.generateSummary(processedVulns);
      const coverage = await this.calculateCoverage(projectPath, scanConfig);
      const recommendations = this.generateRecommendations(processedVulns, summary);

      const endTime = new Date();
      const finalResult: ScanResult = {
        ...scanResult,
        endTime,
        duration: endTime.getTime() - startTime.getTime(),
        vulnerabilities: processedVulns,
        summary,
        coverage,
        recommendations
      };

      this.activeScans.delete(scanId);
      this.scanHistory.push(finalResult);

      return finalResult;
    } catch (error) {
      this.activeScans.delete(scanId);
      throw new MCPError('SECURITY_SCAN_FAILED', `Security scan failed: ${error.message}`);
    }
  }

  private async executeScanType(scanType: ScanType, projectPath: string, config: SecurityScanConfig): Promise<VulnerabilityReport[]> {
    switch (scanType) {
      case 'dependencies':
        return this.scanDependencies(projectPath);
      case 'static_analysis':
        return this.scanStaticAnalysis(projectPath, config);
      case 'secrets':
        return this.scanSecrets(projectPath);
      case 'permissions':
        return this.scanPermissions(projectPath);
      case 'configuration':
        return this.scanConfiguration(projectPath);
      case 'containers':
        return this.scanContainers(projectPath);
      case 'infrastructure':
        return this.scanInfrastructure(projectPath);
      default:
        return [];
    }
  }

  private async scanDependencies(projectPath: string): Promise<VulnerabilityReport[]> {
    const vulnerabilities: VulnerabilityReport[] = [];

    try {
      // Node.js npm audit
      if (await this.fileExists(path.join(projectPath, 'package.json'))) {
        const npmVulns = await this.runNpmAudit(projectPath);
        vulnerabilities.push(...npmVulns);
      }

      // Python pip audit
      if (await this.fileExists(path.join(projectPath, 'requirements.txt')) || 
          await this.fileExists(path.join(projectPath, 'Pipfile'))) {
        const pipVulns = await this.runPipAudit(projectPath);
        vulnerabilities.push(...pipVulns);
      }

      // Java Maven/Gradle
      if (await this.fileExists(path.join(projectPath, 'pom.xml')) || 
          await this.fileExists(path.join(projectPath, 'build.gradle'))) {
        const javaVulns = await this.runJavaAudit(projectPath);
        vulnerabilities.push(...javaVulns);
      }

      // Go modules
      if (await this.fileExists(path.join(projectPath, 'go.mod'))) {
        const goVulns = await this.runGoAudit(projectPath);
        vulnerabilities.push(...goVulns);
      }

      // Rust Cargo
      if (await this.fileExists(path.join(projectPath, 'Cargo.toml'))) {
        const rustVulns = await this.runRustAudit(projectPath);
        vulnerabilities.push(...rustVulns);
      }
    } catch (error) {
      console.error('Dependency scan error:', error);
    }

    return vulnerabilities;
  }

  private async scanStaticAnalysis(projectPath: string, config: SecurityScanConfig): Promise<VulnerabilityReport[]> {
    const vulnerabilities: VulnerabilityReport[] = [];

    try {
      // Use Semgrep for multi-language static analysis
      if (config.integrations.find(i => i.name === 'semgrep' && i.enabled)) {
        const semgrepVulns = await this.runSemgrep(projectPath);
        vulnerabilities.push(...semgrepVulns);
      }

      // ESLint security for JavaScript/TypeScript
      if (config.integrations.find(i => i.name === 'eslint_security' && i.enabled)) {
        const eslintVulns = await this.runESLintSecurity(projectPath);
        vulnerabilities.push(...eslintVulns);
      }

      // Bandit for Python
      if (config.integrations.find(i => i.name === 'bandit' && i.enabled)) {
        const banditVulns = await this.runBandit(projectPath);
        vulnerabilities.push(...banditVulns);
      }

      // Custom rules
      const customVulns = await this.runCustomRules(projectPath, config.customRules);
      vulnerabilities.push(...customVulns);
    } catch (error) {
      console.error('Static analysis scan error:', error);
    }

    return vulnerabilities;
  }

  private async scanSecrets(projectPath: string): Promise<VulnerabilityReport[]> {
    const vulnerabilities: VulnerabilityReport[] = [];
    const secretPatterns = [
      { name: 'AWS Access Key', pattern: /AKIA[0-9A-Z]{16}/, severity: 'critical' as const },
      { name: 'API Key', pattern: /(?:api[_-]?key|apikey)['"]*\s*[:=]\s*['"][^'"]{20,}['"]/, severity: 'high' as const },
      { name: 'Private Key', pattern: /-----BEGIN (RSA )?PRIVATE KEY-----/, severity: 'critical' as const },
      { name: 'Database Password', pattern: /(?:password|pwd)['"]*\s*[:=]\s*['"][^'"]{8,}['"]/, severity: 'high' as const },
      { name: 'JWT Token', pattern: /eyJ[A-Za-z0-9_-]*\.eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*/, severity: 'medium' as const }
    ];

    try {
      const files = await this.getAllFiles(projectPath, ['.git', 'node_modules', '.env']);
      
      for (const file of files) {
        const content = await fs.readFile(file, 'utf-8');
        const lines = content.split('\n');

        for (let i = 0; i < lines.length; i++) {
          for (const pattern of secretPatterns) {
            if (pattern.pattern.test(lines[i])) {
              vulnerabilities.push({
                id: this.generateVulnId(),
                severity: pattern.severity,
                type: 'secret',
                title: `Exposed ${pattern.name}`,
                description: `Potential ${pattern.name} found in source code`,
                affectedFiles: [file],
                remediation: [{
                  type: 'removal',
                  description: `Remove the ${pattern.name} from source code and use environment variables`,
                  priority: 'immediate',
                  effort: 'easy',
                  testRequired: false
                }],
                confidence: 85,
                detectedBy: ['secret_scanner'],
                createdAt: new Date(),
                status: 'open'
              });
            }
          }
        }
      }
    } catch (error) {
      console.error('Secret scan error:', error);
    }

    return vulnerabilities;
  }

  private async scanPermissions(projectPath: string): Promise<VulnerabilityReport[]> {
    const vulnerabilities: VulnerabilityReport[] = [];

    try {
      // Android permissions
      const manifestPath = path.join(projectPath, 'android/app/src/main/AndroidManifest.xml');
      if (await this.fileExists(manifestPath)) {
        const androidVulns = await this.scanAndroidPermissions(manifestPath);
        vulnerabilities.push(...androidVulns);
      }

      // iOS permissions
      const plistPath = path.join(projectPath, 'ios/Info.plist');
      if (await this.fileExists(plistPath)) {
        const iosVulns = await this.scanIOSPermissions(plistPath);
        vulnerabilities.push(...iosVulns);
      }

      // File permissions
      const filePermVulns = await this.scanFilePermissions(projectPath);
      vulnerabilities.push(...filePermVulns);
    } catch (error) {
      console.error('Permission scan error:', error);
    }

    return vulnerabilities;
  }

  private async scanConfiguration(projectPath: string): Promise<VulnerabilityReport[]> {
    const vulnerabilities: VulnerabilityReport[] = [];

    try {
      // Docker configuration
      const dockerfiles = await this.findFiles(projectPath, 'Dockerfile*');
      for (const dockerfile of dockerfiles) {
        const dockerVulns = await this.scanDockerfile(dockerfile);
        vulnerabilities.push(...dockerVulns);
      }

      // Web server configuration
      const nginxConfigs = await this.findFiles(projectPath, '*.conf');
      for (const config of nginxConfigs) {
        const nginxVulns = await this.scanNginxConfig(config);
        vulnerabilities.push(...nginxVulns);
      }

      // Database configuration
      const dbConfigs = await this.findFiles(projectPath, '*config*.{json,yaml,yml}');
      for (const config of dbConfigs) {
        const dbVulns = await this.scanDatabaseConfig(config);
        vulnerabilities.push(...dbVulns);
      }
    } catch (error) {
      console.error('Configuration scan error:', error);
    }

    return vulnerabilities;
  }

  private async scanContainers(projectPath: string): Promise<VulnerabilityReport[]> {
    const vulnerabilities: VulnerabilityReport[] = [];

    try {
      // Docker image vulnerabilities
      const dockerComposeFiles = await this.findFiles(projectPath, 'docker-compose*.{yml,yaml}');
      for (const file of dockerComposeFiles) {
        const containerVulns = await this.scanDockerCompose(file);
        vulnerabilities.push(...containerVulns);
      }
    } catch (error) {
      console.error('Container scan error:', error);
    }

    return vulnerabilities;
  }

  private async scanInfrastructure(projectPath: string): Promise<VulnerabilityReport[]> {
    const vulnerabilities: VulnerabilityReport[] = [];

    try {
      // Terraform files
      const terraformFiles = await this.findFiles(projectPath, '*.tf');
      for (const file of terraformFiles) {
        const terraformVulns = await this.scanTerraform(file);
        vulnerabilities.push(...terraformVulns);
      }

      // Kubernetes manifests
      const k8sFiles = await this.findFiles(projectPath, '*.{yaml,yml}');
      for (const file of k8sFiles) {
        const k8sVulns = await this.scanKubernetes(file);
        vulnerabilities.push(...k8sVulns);
      }
    } catch (error) {
      console.error('Infrastructure scan error:', error);
    }

    return vulnerabilities;
  }

  // Utility methods
  private generateScanId(): string {
    return `scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private generateVulnId(): string {
    return `vuln_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private async fileExists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  private async getAllFiles(dir: string, exclude: string[] = []): Promise<string[]> {
    const files: string[] = [];
    const items = await fs.readdir(dir, { withFileTypes: true });

    for (const item of items) {
      if (exclude.some(ex => item.name.includes(ex))) continue;

      const fullPath = path.join(dir, item.name);
      if (item.isDirectory()) {
        files.push(...await this.getAllFiles(fullPath, exclude));
      } else {
        files.push(fullPath);
      }
    }

    return files;
  }

  private async findFiles(dir: string, pattern: string): Promise<string[]> {
    // Simplified file finder - in production, use glob or similar
    const files = await this.getAllFiles(dir);
    return files.filter(file => file.includes(pattern.replace('*', '')));
  }

  private processVulnerabilities(vulnerabilities: VulnerabilityReport[]): VulnerabilityReport[] {
    // Deduplicate and merge similar vulnerabilities
    const deduped = new Map<string, VulnerabilityReport>();

    for (const vuln of vulnerabilities) {
      const key = `${vuln.type}_${vuln.title}_${vuln.affectedFiles.join(',')}`;
      if (!deduped.has(key)) {
        deduped.set(key, vuln);
      } else {
        // Merge confidence scores and detected by
        const existing = deduped.get(key)!;
        existing.confidence = Math.max(existing.confidence, vuln.confidence);
        existing.detectedBy = Array.from(new Set([...existing.detectedBy, ...vuln.detectedBy]));
      }
    }

    return Array.from(deduped.values()).sort((a, b) => {
      const severityOrder = { critical: 4, high: 3, medium: 2, low: 1, info: 0 };
      return severityOrder[b.severity] - severityOrder[a.severity];
    });
  }

  private generateSummary(vulnerabilities: VulnerabilityReport[]): SecuritySummary {
    const summary: SecuritySummary = {
      total: vulnerabilities.length,
      bySeverity: { critical: 0, high: 0, medium: 0, low: 0, info: 0 },
      byType: { dependency: 0, code: 0, configuration: 0, secret: 0, permission: 0 },
      byPlatform: {} as Record<Platform, number>,
      riskScore: 0,
      complianceScore: 0
    };

    for (const vuln of vulnerabilities) {
      summary.bySeverity[vuln.severity]++;
      summary.byType[vuln.type]++;
    }

    // Calculate risk score (0-100, lower is better)
    summary.riskScore = Math.min(100, 
      summary.bySeverity.critical * 25 + 
      summary.bySeverity.high * 10 + 
      summary.bySeverity.medium * 5 + 
      summary.bySeverity.low * 1
    );

    // Calculate compliance score (0-100, higher is better)
    summary.complianceScore = Math.max(0, 100 - summary.riskScore);

    return summary;
  }

  private async calculateCoverage(projectPath: string, config: SecurityScanConfig): Promise<CoverageReport> {
    const allFiles = await this.getAllFiles(projectPath);
    const codeFiles = allFiles.filter(file => 
      /\.(js|ts|py|java|go|rs|rb|php|cs|cpp|c|h)$/.test(file)
    );

    return {
      filesScanned: codeFiles.length,
      totalFiles: allFiles.length,
      linesScanned: 0, // Would need to count actual lines
      totalLines: 0,
      platformsCovered: config.platforms,
      scanTypesExecuted: config.scanTypes
    };
  }

  private generateRecommendations(vulnerabilities: VulnerabilityReport[], summary: SecuritySummary): string[] {
    const recommendations: string[] = [];

    if (summary.bySeverity.critical > 0) {
      recommendations.push('🚨 Address critical vulnerabilities immediately - these pose immediate security risks');
    }

    if (summary.byType.secret > 0) {
      recommendations.push('🔐 Implement proper secret management using environment variables or secret vaults');
    }

    if (summary.byType.dependency > 5) {
      recommendations.push('📦 Consider implementing automated dependency update policies');
    }

    if (summary.riskScore > 50) {
      recommendations.push('⚠️ Overall security posture needs improvement - prioritize high-impact fixes');
    }

    if (summary.complianceScore < 80) {
      recommendations.push('📋 Review security policies and implement additional security controls');
    }

    return recommendations;
  }

  private createEmptySummary(): SecuritySummary {
    return {
      total: 0,
      bySeverity: { critical: 0, high: 0, medium: 0, low: 0, info: 0 },
      byType: { dependency: 0, code: 0, configuration: 0, secret: 0, permission: 0 },
      byPlatform: {} as Record<Platform, number>,
      riskScore: 0,
      complianceScore: 100
    };
  }

  private createEmptyCoverage(): CoverageReport {
    return {
      filesScanned: 0,
      totalFiles: 0,
      linesScanned: 0,
      totalLines: 0,
      platformsCovered: [],
      scanTypesExecuted: []
    };
  }

  // Placeholder methods for specific scanners
  private async runNpmAudit(projectPath: string): Promise<VulnerabilityReport[]> {
    // Implementation would run npm audit and parse results
    return [];
  }

  private async runPipAudit(projectPath: string): Promise<VulnerabilityReport[]> {
    // Implementation would run pip-audit or safety and parse results
    return [];
  }

  private async runJavaAudit(projectPath: string): Promise<VulnerabilityReport[]> {
    // Implementation would run OWASP dependency check and parse results
    return [];
  }

  private async runGoAudit(projectPath: string): Promise<VulnerabilityReport[]> {
    // Implementation would run govulncheck and parse results
    return [];
  }

  private async runRustAudit(projectPath: string): Promise<VulnerabilityReport[]> {
    // Implementation would run cargo audit and parse results
    return [];
  }

  private async runSemgrep(projectPath: string): Promise<VulnerabilityReport[]> {
    // Implementation would run semgrep and parse results
    return [];
  }

  private async runESLintSecurity(projectPath: string): Promise<VulnerabilityReport[]> {
    // Implementation would run eslint with security plugins
    return [];
  }

  private async runBandit(projectPath: string): Promise<VulnerabilityReport[]> {
    // Implementation would run bandit and parse results
    return [];
  }

  private async runCustomRules(projectPath: string, rules: SecurityRule[]): Promise<VulnerabilityReport[]> {
    // Implementation would apply custom security rules
    return [];
  }

  private async scanAndroidPermissions(manifestPath: string): Promise<VulnerabilityReport[]> {
    // Implementation would parse AndroidManifest.xml and check permissions
    return [];
  }

  private async scanIOSPermissions(plistPath: string): Promise<VulnerabilityReport[]> {
    // Implementation would parse Info.plist and check permissions
    return [];
  }

  private async scanFilePermissions(projectPath: string): Promise<VulnerabilityReport[]> {
    // Implementation would check file system permissions
    return [];
  }

  private async scanDockerfile(dockerfilePath: string): Promise<VulnerabilityReport[]> {
    // Implementation would analyze Dockerfile for security issues
    return [];
  }

  private async scanNginxConfig(configPath: string): Promise<VulnerabilityReport[]> {
    // Implementation would analyze nginx configuration
    return [];
  }

  private async scanDatabaseConfig(configPath: string): Promise<VulnerabilityReport[]> {
    // Implementation would analyze database configuration
    return [];
  }

  private async scanDockerCompose(composePath: string): Promise<VulnerabilityReport[]> {
    // Implementation would analyze docker-compose.yml
    return [];
  }

  private async scanTerraform(terraformPath: string): Promise<VulnerabilityReport[]> {
    // Implementation would analyze Terraform files
    return [];
  }

  private async scanKubernetes(k8sPath: string): Promise<VulnerabilityReport[]> {
    // Implementation would analyze Kubernetes manifests
    return [];
  }

  // Public API methods
  async getHealthStatus(): Promise<any> {
    return {
      status: 'healthy',
      activeScans: this.activeScans.size,
      totalScansCompleted: this.scanHistory.length,
      lastScanTime: this.scanHistory.length > 0 ? this.scanHistory[this.scanHistory.length - 1].endTime : null,
      integrations: this.config.integrations.filter(i => i.enabled).map(i => i.name)
    };
  }

  async listScans(): Promise<ScanResult[]> {
    return this.scanHistory.slice(-10); // Return last 10 scans
  }

  async getScanResult(scanId: string): Promise<ScanResult | null> {
    return this.scanHistory.find(scan => scan.scanId === scanId) || null;
  }

  async getVulnerabilityById(vulnId: string): Promise<VulnerabilityReport | null> {
    for (const scan of this.scanHistory) {
      const vuln = scan.vulnerabilities.find(v => v.id === vulnId);
      if (vuln) return vuln;
    }
    return null;
  }

  async updateVulnerabilityStatus(vulnId: string, status: VulnerabilityReport['status']): Promise<boolean> {
    for (const scan of this.scanHistory) {
      const vuln = scan.vulnerabilities.find(v => v.id === vulnId);
      if (vuln) {
        vuln.status = status;
        return true;
      }
    }
    return false;
  }

  async generateReport(scanId: string, format: ReportingConfig['format'] = 'json'): Promise<string> {
    const scan = await this.getScanResult(scanId);
    if (!scan) {
      throw new MCPError('SCAN_NOT_FOUND', `Scan ${scanId} not found`);
    }

    switch (format) {
      case 'json':
        return JSON.stringify(scan, null, 2);
      case 'html':
        return this.generateHTMLReport(scan);
      case 'csv':
        return this.generateCSVReport(scan);
      case 'sarif':
        return this.generateSARIFReport(scan);
      default:
        throw new MCPError('INVALID_FORMAT', `Unsupported format: ${format}`);
    }
  }

  private generateHTMLReport(scan: ScanResult): string {
    // Implementation would generate HTML report
    return `<html><body><h1>Security Scan Report</h1><p>Scan ID: ${scan.scanId}</p></body></html>`;
  }

  private generateCSVReport(scan: ScanResult): string {
    // Implementation would generate CSV report
    const header = 'ID,Severity,Type,Title,Files,Status\n';
    const rows = scan.vulnerabilities.map(v => 
      `${v.id},${v.severity},${v.type},${v.title},"${v.affectedFiles.join(';')}",${v.status}`
    ).join('\n');
    return header + rows;
  }

  private generateSARIFReport(scan: ScanResult): string {
    // Implementation would generate SARIF format report
    return JSON.stringify({
      version: '2.1.0',
      runs: [{
        tool: { driver: { name: 'SecurityVulnerabilityMCP' } },
        results: scan.vulnerabilities.map(v => ({
          ruleId: v.type,
          level: v.severity === 'critical' ? 'error' : v.severity === 'high' ? 'warning' : 'note',
          message: { text: v.description },
          locations: v.affectedFiles.map(file => ({
            physicalLocation: { artifactLocation: { uri: file } }
          }))
        }))
      }]
    }, null, 2);
  }
}

// Security Vulnerability MCP Server
export class SecurityVulnerabilityServer extends BaseMCPServer {
  private securityService: SecurityVulnerabilityService;
  
  // Memory optimization: Enable garbage collection and monitoring
  private memoryMonitorInterval: NodeJS.Timeout | null = null;

  constructor() {
    const config = {
      name: 'security-vulnerability-server',
      port: parseInt(process.env.SECURITY_VULNERABILITY_PORT || '3016'),
      enableCors: true,
      enableSecurity: true,
      healthCheck: {
        enabled: true,
        path: '/health',
        interval: 30000
      }
    };

    super(config);

    // Default security configuration
    const defaultSecurityConfig: SecurityScanConfig = {
      scanTypes: ['dependencies', 'static_analysis', 'secrets', 'configuration'],
      platforms: ['web', 'nodejs', 'python'],
      excludePatterns: ['node_modules', '.git', 'dist', 'build'],
      customRules: [],
      integrations: [
        { name: 'npm_audit', type: 'npm_audit', config: {}, enabled: true },
        { name: 'semgrep', type: 'semgrep', config: {}, enabled: false },
        { name: 'eslint_security', type: 'eslint_security', config: {}, enabled: true }
      ],
      reporting: {
        format: 'json',
        includeRemediation: true,
        includeCVEDetails: true,
        groupBy: 'severity',
        metrics: true
      }
    };

    this.securityService = new SecurityVulnerabilityService(defaultSecurityConfig);
  }

  protected async initialize(): Promise<void> {
    this.setupSecurityRoutes();
    this.startMemoryMonitoring();
  }

  protected async cleanup(): Promise<void> {
    if (this.memoryMonitorInterval) {
      clearInterval(this.memoryMonitorInterval);
      this.memoryMonitorInterval = null;
    }
    
    // Clear caches to free memory
    if (this.securityService) {
      this.securityService.clearCaches();
    }
    
    // Force garbage collection if available
    if (global.gc) {
      global.gc();
    }
  }
  
  private startMemoryMonitoring(): void {
    this.memoryMonitorInterval = setInterval(() => {
      const memUsage = process.memoryUsage();
      const heapUsedMB = Math.round(memUsage.heapUsed / 1024 / 1024);
      const heapTotalMB = Math.round(memUsage.heapTotal / 1024 / 1024);
      const rssMB = Math.round(memUsage.rss / 1024 / 1024);
      
      // Log memory usage
      console.log(`[Security] Memory: Heap ${heapUsedMB}/${heapTotalMB}MB, RSS: ${rssMB}MB`);
      
      // Trigger GC if memory usage is high
      if (heapUsedMB > 50 && global.gc) {
        console.log('[Security] Triggering garbage collection...');
        global.gc();
      }
      
      // Clear caches if memory usage is critical
      if (heapUsedMB > 80) {
        console.log('[Security] Memory critical, clearing caches...');
        this.securityService.clearCaches();
      }
    }, 30000); // Check every 30 seconds
  }

  private setupSecurityRoutes(): void {
    // Health check
    this.addRoute('get', '/health', async (req, res) => {
      try {
        const health = await this.securityService.getHealthStatus();
        res.json(health);
      } catch (error) {
        res.status(500).json({ error: (error as Error).message });
      }
    });

    // Scan project
    this.addRoute('post', '/api/scan', async (req, res) => {
      try {
        const { projectPath, config } = req.body;
        if (!projectPath) {
          return res.status(400).json({ error: 'projectPath is required' });
        }

        const result = await this.securityService.scanProject(projectPath, config);
        res.json(result);
      } catch (error) {
        res.status(500).json({ error: (error as Error).message });
      }
    });

    // List scans
    this.addRoute('get', '/api/scans', async (req, res) => {
      try {
        const scans = await this.securityService.listScans();
        res.json(scans);
      } catch (error) {
        res.status(500).json({ error: (error as Error).message });
      }
    });

    // Get scan result
    this.addRoute('get', '/api/scans/:scanId', async (req, res) => {
      try {
        const { scanId } = req.params;
        const scan = await this.securityService.getScanResult(scanId);
        if (!scan) {
          return res.status(404).json({ error: 'Scan not found' });
        }
        res.json(scan);
      } catch (error) {
        res.status(500).json({ error: (error as Error).message });
      }
    });

    // Get vulnerability
    this.addRoute('get', '/api/vulnerabilities/:vulnId', async (req, res) => {
      try {
        const { vulnId } = req.params;
        const vuln = await this.securityService.getVulnerabilityById(vulnId);
        if (!vuln) {
          return res.status(404).json({ error: 'Vulnerability not found' });
        }
        res.json(vuln);
      } catch (error) {
        res.status(500).json({ error: (error as Error).message });
      }
    });

    // Update vulnerability status
    this.addRoute('patch', '/api/vulnerabilities/:vulnId', async (req, res) => {
      try {
        const { vulnId } = req.params;
        const { status } = req.body;
        const updated = await this.securityService.updateVulnerabilityStatus(vulnId, status);
        if (!updated) {
          return res.status(404).json({ error: 'Vulnerability not found' });
        }
        res.json({ success: true });
      } catch (error) {
        res.status(500).json({ error: (error as Error).message });
      }
    });

    // Generate report
    this.addRoute('get', '/api/scans/:scanId/report', async (req, res) => {
      try {
        const { scanId } = req.params;
        const { format = 'json' } = req.query;
        const report = await this.securityService.generateReport(scanId, format as any);
        
        const contentType = {
          json: 'application/json',
          html: 'text/html',
          csv: 'text/csv',
          sarif: 'application/json'
        }[format as string] || 'application/json';
        
        res.set('Content-Type', contentType);
        res.send(report);
      } catch (error) {
        res.status(500).json({ error: (error as Error).message });
      }
    });

    // MCP Tools endpoint
    this.addRoute('get', '/api/tools', async (req, res) => {
      res.json({
        tools: [
          {
            name: 'scan_project_security',
            description: 'Perform comprehensive security vulnerability scan on a project',
            parameters: {
              type: 'object',
              properties: {
                projectPath: { type: 'string', description: 'Path to the project to scan' },
                scanTypes: { 
                  type: 'array', 
                  items: { enum: ['dependencies', 'static_analysis', 'secrets', 'permissions', 'configuration', 'containers', 'infrastructure'] },
                  description: 'Types of security scans to perform'
                },
                platforms: {
                  type: 'array',
                  items: { enum: ['web', 'nodejs', 'python', 'java', 'csharp', 'go', 'rust', 'php', 'ruby', 'mobile_ios', 'mobile_android', 'flutter', 'react_native'] },
                  description: 'Target platforms to scan for'
                }
              },
              required: ['projectPath']
            }
          },
          {
            name: 'get_vulnerability_details',
            description: 'Get detailed information about a specific vulnerability',
            parameters: {
              type: 'object',
              properties: {
                vulnerabilityId: { type: 'string', description: 'ID of the vulnerability to retrieve' }
              },
              required: ['vulnerabilityId']
            }
          },
          {
            name: 'update_vulnerability_status',
            description: 'Update the status of a vulnerability (mark as fixed, false positive, etc.)',
            parameters: {
              type: 'object',
              properties: {
                vulnerabilityId: { type: 'string', description: 'ID of the vulnerability to update' },
                status: { 
                  type: 'string', 
                  enum: ['open', 'triaged', 'fixed', 'false_positive', 'accepted_risk'],
                  description: 'New status for the vulnerability'
                }
              },
              required: ['vulnerabilityId', 'status']
            }
          },
          {
            name: 'generate_security_report',
            description: 'Generate a security report for a completed scan',
            parameters: {
              type: 'object',
              properties: {
                scanId: { type: 'string', description: 'ID of the scan to generate report for' },
                format: { 
                  type: 'string', 
                  enum: ['json', 'html', 'csv', 'sarif'],
                  description: 'Format of the report to generate'
                }
              },
              required: ['scanId']
            }
          },
          {
            name: 'list_recent_scans',
            description: 'List recent security scans performed',
            parameters: {
              type: 'object',
              properties: {
                limit: { type: 'number', description: 'Maximum number of scans to return', default: 10 }
              }
            }
          },
          {
            name: 'check_dependency_vulnerabilities',
            description: 'Quick check for known vulnerabilities in project dependencies',
            parameters: {
              type: 'object',
              properties: {
                projectPath: { type: 'string', description: 'Path to the project to check' },
                packageManager: { 
                  type: 'string', 
                  enum: ['npm', 'yarn', 'pip', 'maven', 'gradle', 'go', 'cargo'],
                  description: 'Package manager to use for vulnerability checking'
                }
              },
              required: ['projectPath']
            }
          },
          {
            name: 'scan_for_exposed_secrets',
            description: 'Scan project files for exposed API keys, passwords, and other secrets',
            parameters: {
              type: 'object',
              properties: {
                projectPath: { type: 'string', description: 'Path to the project to scan' },
                excludePatterns: { 
                  type: 'array', 
                  items: { type: 'string' },
                  description: 'File patterns to exclude from scanning'
                }
              },
              required: ['projectPath']
            }
          },
          {
            name: 'analyze_security_trends',
            description: 'Analyze security trends across multiple scans to identify patterns',
            parameters: {
              type: 'object',
              properties: {
                timeRange: { 
                  type: 'string', 
                  enum: ['7d', '30d', '90d', '1y'],
                  description: 'Time range for trend analysis'
                },
                projectPath: { type: 'string', description: 'Optional: Filter trends for specific project' }
              }
            }
          }
        ]
      });
    });
  }

  // MCP tool implementations
  async callTool(toolName: string, parameters: any): Promise<any> {
    switch (toolName) {
      case 'scan_project_security':
        return this.securityService.scanProject(parameters.projectPath, {
          scanTypes: parameters.scanTypes,
          platforms: parameters.platforms
        });

      case 'get_vulnerability_details':
        return this.securityService.getVulnerabilityById(parameters.vulnerabilityId);

      case 'update_vulnerability_status':
        return this.securityService.updateVulnerabilityStatus(parameters.vulnerabilityId, parameters.status);

      case 'generate_security_report':
        return this.securityService.generateReport(parameters.scanId, parameters.format);

      case 'list_recent_scans':
        return this.securityService.listScans();

      case 'check_dependency_vulnerabilities':
        return this.securityService.scanProject(parameters.projectPath, {
          scanTypes: ['dependencies'],
          platforms: ['web', 'nodejs', 'python'] // Auto-detect based on project
        });

      case 'scan_for_exposed_secrets':
        return this.securityService.scanProject(parameters.projectPath, {
          scanTypes: ['secrets'],
          excludePatterns: parameters.excludePatterns
        });

      case 'analyze_security_trends':
        // Implementation would analyze historical scan data
        return { 
          message: 'Security trend analysis not yet implemented',
          timeRange: parameters.timeRange 
        };

      default:
        throw new MCPError('UNKNOWN_TOOL', `Unknown tool: ${toolName}`);
    }
  }

  async listTools(): Promise<any[]> {
    const response = await fetch(`http://localhost:${this.config.port}/api/tools`);
    const data = await response.json();
    return data.tools;
  }
}

// Start the server if this file is run directly
if (import.meta.url === `file://${process.argv[1]}`) {
  const server = new SecurityVulnerabilityServer();
  server.start().catch(console.error);
}